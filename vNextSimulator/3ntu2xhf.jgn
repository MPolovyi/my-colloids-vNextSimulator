#pragma once
#include "Simulator.h"
#include <thread>

class CDataSnap
{
	typedef std::tuple<blaze::Vec2d, blaze::Vec2d, blaze::Vec2d, double> Coord_AreaExtent_Velocity_NumParticles;
	typedef std::tuple<blaze::Vec2d, blaze::Vec2d, double, double> Coord_AreaExtent_Dencity_NumParticles;
public:
	template<size_t spDim>
	CDataSnap(Simulator::CSimulator<spDim>& s)
	{
		std::cout << "Creating data snap" << std::endl;
		SaveMiscInfo(s);
		SaveParticleData(s);
		SaveVelocityData(s);
		SaveDencityData(s);
	};
	~CDataSnap() {};

	int ParticleCount;
	double ParticleVelocity;
	int stepsFromStart;
	double Noise;
	std::string simGuid;

	//Previous noise, Steps with previous noises
	std::vector<std::pair<double, int>> PreviousSimulations;

	//Coordinate, Velocity
	std::vector<std::pair<blaze::Vec2d, blaze::Vec2d>> ParticleData;
	
	//Coordinate, AreaExtents, Velocity, NumParticles
	std::vector<Coord_AreaExtent_Velocity_NumParticles> AverageVelocityData;

	//Coordinate, AreaExtents, Dencity, NumParticles
	std::vector<Coord_AreaExtent_Dencity_NumParticles> AverageDencityData;

	template<size_t spDim> void SaveMiscInfo(Simulator::CSimulator<spDim>& s)
	{
		simGuid = s.Guid;
		stepsFromStart = s.Steps;
		Noise = s.GetNoise();
		PreviousSimulations = std::vector<std::pair<double, int>>(s.PreviousNoises.begin(), s.PreviousNoises.end());
		ParticleCount = s.GetParticleCount();
		ParticleVelocity = s.GetParticleVelocity();
	};
	template<size_t spDim> void SaveParticleData(Simulator::CSimulator<spDim>& s)
	{
		auto particleDat = s.GetParticles();
		ParticleData.reserve(particleDat.size());
		for (auto particle : particleDat)
		{
			ParticleData.push_back(std::pair<blaze::StaticVector<double, spDim>, blaze::StaticVector<double, spDim>>(
				blaze::StaticVector<double, spDim>(particle.Coords),
				blaze::StaticVector<double, spDim>(particle.Velocity)));
		}
	};
	template<size_t spDim> void SaveVelocityData(Simulator::CSimulator<spDim>& s)
	{
		SaveVelocityData(s, PrepareSquareExtents(s.Extents, 10, 10));
	};
	template<size_t spDim> void SaveDencityData(Simulator::CSimulator<spDim>& s)
	{
		SaveDencityData(s, PrepareSquareExtents(s.Extents, 10, 10));
	};
	template<size_t spDim> void SaveVelocityData(Simulator::CSimulator<spDim>& s, std::vector<std::pair<blaze::Vec2d, blaze::Vec2d>>& CoordsAndExtents)
	{
		std::vector<blaze::StaticVector<double, spDim>> result;
		result.resize(CoordsAndExtents.size());

		std::vector<int> particleCount;
		particleCount.resize(CoordsAndExtents.size());

		auto particles = s.GetParticles();

		std::vector<std::thread> workers;
		for (int i = 0; i < CoordsAndExtents.size(); i++)
		{
			workers.push_back(std::thread(
				[](std::vector<blaze::StaticVector<double, spDim>>& result,
				std::vector<Simulator::CParticle<spDim>>& particles,
				std::vector<std::pair<blaze::StaticVector<double, spDim>, blaze::StaticVector<double, spDim>>>& CoordsAndExtents,
				std::vector<int>& particleCount,
				int index) {
				for (auto particle : particles)
				{
					blaze::StaticVector<double, spDim> particleVector = blaze::abs(particle.Coords - CoordsAndExtents[index].first);

					if (particleVector[0] <= CoordsAndExtents[index].second[0] &&
						particleVector[1] <= CoordsAndExtents[index].second[1])
					{
						result[index] += particle.Velocity;
						particleCount[index] += 1;
					}
				}}, std::ref(result), std::ref(particles), std::ref(CoordsAndExtents), std::ref(particleCount), i));
		}
		std::for_each(workers.begin(), workers.end(), [](std::thread &t) { t.join(); });

		for (int i = 0; i < result.size(); i++)
		{
			AverageVelocityData.push_back(
				Coord_AreaExtent_Velocity_NumParticles(
				CoordsAndExtents[i].first, CoordsAndExtents[i].second, result[i] / particleCount[i], particleCount[i]));
		}
	};
	template<size_t spDim> void SaveDencityData(Simulator::CSimulator<spDim>& s, std::vector<std::pair<blaze::Vec2d, blaze::Vec2d>>& CoordsAndExtents)
	{
		std::vector<double> result;
		result.resize(CoordsAndExtents.size());

		std::vector<double> squares;
		squares.resize(CoordsAndExtents.size());

		double square = s.Extents[0] * s.Extents[1];

		auto particles = s.GetParticles();

		std::vector<std::thread> workers;
		for (int i = 0; i < CoordsAndExtents.size(); i++)
		{
			workers.push_back(std::thread(
				[](std::vector<double>& result,
				std::vector<Simulator::CParticle>& particles,
				std::vector<std::pair<blaze::StaticVector<double, spDim>, blaze::StaticVector<double, spDim>>>& CoordsAndExtents,
				int index) {
				for (auto particle : particles)
				{
					blaze::StaticVector<double, spDim> particleVector = blaze::abs(particle.Coords - CoordsAndExtents[index].first);
					if (particleVector[0] <= CoordsAndExtents[index].second[0] &&
						particleVector[1] <= CoordsAndExtents[index].second[1])
					{
						result[index] += 1;
					}
				}}, std::ref(result), std::ref(particles), std::ref(CoordsAndExtents), i));

				squares[i] = CoordsAndExtents[i].second[0] * CoordsAndExtents[i].second[0];
		}

		std::for_each(workers.begin(), workers.end(), [](std::thread &t) { t.join(); });


		for (int i = 0; i < CoordsAndExtents.size(); i++)
		{
			AverageDencityData.push_back(
				Coord_AreaExtent_Dencity_NumParticles(CoordsAndExtents[i].first, CoordsAndExtents[i].second, result[i] / squares[i], result[i]));
		}
	};

	std::vector<std::pair<blaze::Vec2d, blaze::Vec2d>> PrepareSquareExtents(blaze::Vec2d squareArea, int numX, int numY);
};